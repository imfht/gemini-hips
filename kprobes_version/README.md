# HIPS 内核模块 (hips_kmod)

## 概述

本项目是一个通过Linux内核模块（Kernel Module）实现的、简单的主机入侵防御系统（HIPS）。

它的核心功能是监控系统上所有新进程的创建，并根据一个可以动态配置的黑名单，在进程执行之前就将其**同步拦截**，从而阻止潜在的恶意程序运行。本项目旨在以一个强大、底层的示例，来演示如何在操作系统内核层面直接进行系统安全监控与防护。

---

## 主要特性

- **实时进程拦截**：在进程执行前的一瞬间进行拦截，而非事后补救。
- **内核级性能**：所有核心逻辑直接在内核态运行，无用户态/内核态切换开销，性能极高。
- **Kprobes技术**：使用内核官方的动态探测框架 `kprobes` 来高效、稳定地挂钩（Hook）系统调用。
- **动态配置**：通过 `/proc` 文件系统 (`/proc/hips_blacklist`)，可以在不重新加载模块的情况下，动态更新黑名单规则。
- **内核日志**：所有拦截事件都会被记录到内核日志缓冲区，可通过 `dmesg` 命令查看。

---

## 工作原理详解

理解本模块的核心在于理解我们是如何利用 `kprobes` 来“欺骗”操作系统的。

### 1. 核心技术：Kprobes

`kprobes` 是Linux内核提供的一个动态探测工具，它允许我们在一个正在运行的内核中，几乎任何函数（甚至函数的某条指令）的入口或出口点插入我们自己的处理函数（handler）。这是一种非侵入式的、用于调试、追踪和监控的强大技术。

### 2. 拦截点：`execve` 系统调用

在Linux中，所有新程序的执行（无论是在终端敲命令，还是点击图形界面的图标）最终都必须通过 `execve` 这个系统调用来完成。因此，它是监控新进程创建的最理想、最根本的拦截点。

我们的模块在内核函数 `__x64_sys_execve`（`execve`系统调用在x86-64架构下的实现）的入口点注册了一个“**前置探针**”（pre-handler）。这意味着，每当系统中有任何进程想要执行一个新程序时，我们的代码会比真正的`execve`代码**更先执行**。

### 3. 拦截流程详解

当一个用户尝试运行一个命令时（例如 `ncat`），会发生以下流程：

1.  `execve` 系统调用被触发。
2.  由于我们注册了kprobe，内核会暂停执行`execve`，转而**立即执行**我们的前置处理函数 `kprobe_pre_handler`。

3.  **提取参数**：我们的处理函数会接收到一个包含所有**CPU寄存器**状态的结构体 `struct pt_regs *regs`。根据x86-64架构的系统调用约定，第一个参数（即要执行的程序的文件名指针）存放在 `DI` 寄存器中。我们的代码通过 `regs->di` 读取到这个文件名指针。

4.  **安全拷贝**：这个指针指向的是用户空间的地址，内核不能直接访问。因此，我们必须使用内核提供的安全函数 `strncpy_from_user`，将程序名从用户空间拷贝到内核的安全内存中。

5.  **黑名单检查**：代码将拷贝到的程序名（例如 `ncat`）与我们内部维护的黑名单列表进行逐一比对。

### 4. 关键的“欺骗”机制：拦截或放行

这是整个模块最精妙的部分。

*   **如果程序不在黑名单中**：
    我们的 `kprobe_pre_handler` 函数直接返回 `0`。这个返回值告诉kprobe框架：“我的事情做完了，请继续执行原始的 `__x64_sys_execve` 函数。” 于是，`ncat` 命令正常执行。

*   **如果程序在黑名单中**：
    我们的处理函数会执行两个关键操作：
    1.  **修改返回码**：代码执行 `regs->ax = -EPERM;`。在x86-64架构下，`AX` 寄存器用于存放系统调用的**返回值**。我们手动将这个返回值设置为了 `-EPERM`（Operation not permitted，操作不允许）。
    2.  **阻止原函数执行**：处理函数返回 `1`。这个特殊的返回值告诉kprobe框架：“**不要再执行原始的 `__x64_sys_execve` 函数了**，到此为止，直接返回。”

    **最终结果**：`execve` 系统调用被我们的探针“劫持”了。原始的加载和执行`ncat`的代码从未被运行。用户的进程收到了一个 `-EPERM` 错误码，并在终端上看到了 `Operation not permitted` 的提示。这就完成了一次完美的、同步的、无法绕过的拦截。

### 5. 动态配置原理

为了方便使用，模块在加载时会通过 `proc_create` 函数在 `/proc` 虚拟文件系统中创建一个名为 `hips_blacklist` 的文件。

我们为这个文件注册了一个“写操作处理函数”（`proc_write_blacklist`）。当您使用 `echo ncat > /proc/hips_blacklist` 命令时，内核会捕获这个写操作，并调用我们的处理函数。该函数会获取您写入的字符串（`ncat`），并将其添加到一个内核内存的数组中（即我们的黑名单列表），从而实现了规则的动态更新。

---

## 项目文件

- `hips_kmod.c`: 内核模块的C语言源代码。
- `Makefile`: 用于编译模块的标准构建脚本。

---

## 编译与使用

**⚠️ 警告：建议在虚拟机中执行以下所有操作。**

1.  **编译模块**:
    ```bash
    make clean && make
    ```

2.  **加载模块到内核**:
    ```bash
    sudo insmod hips_kmod.ko
    ```

3.  **验证加载**:
    ```bash
    dmesg | tail -n 1
    # 应显示 "HIPS Kernel Module Loaded..." 信息
    ```

4.  **配置黑名单**:
    ```bash
    sudo sh -c "echo ncat > /proc/hips_blacklist"
    sudo sh -c "echo wget > /proc/hips_blacklist"
    ```

5.  **测试拦截**:
    ```bash
    ncat -l 1234
    # 命令应立即失败，并显示 "Operation not permitted"
    ```

6.  **查看拦截日志**:
    ```bash
    dmesg | tail
    # 应显示 "BLOCKED execution of..." 信息
    ```

7.  **卸载模块**:
    ```bash
    sudo rmmod hips_kmod
    ```
