# HIPS eBPF 版本

## 概述

本项目是一个通过 **eBPF** 技术实现的、现代化的主机入侵防御系统（HIPS）。它利用 Python 的 `bcc` 库来加载和控制 eBPF 程序，从而安全、高效地监控和拦截 Linux 系统上的进程创建事件。

与传统的内核模块相比，eBPF 方案通过其内置的验证器（Verifier）提供了无与伦比的安全性，杜绝了导致内核崩溃的风险，同时也提供了强大的可编程性。

---

## 主要特性

- **安全可靠**：基于 eBPF 技术，代码在内核的沙箱虚拟机中运行，无法导致系统崩溃。
- **双模式运行**：支持“安全模式”（默认）和“功能模式”（`--functional`），允许用户在“杜绝竞争条件”和“功能兼容性”之间做选择。
- **内核态快速放行**：通过 BPF `hash map` 实现内核级别的白名单，常用命令（如`ls`）可以无延迟、零开销地运行，极大优化了用户体验。
- **精准的 `cmdline` 获取**：独创性地使用“入口/出口探针关联”技术，100%解决了在进程创建瞬间读取命令行参数（`cmdline`）不准确的竞争问题。
- **丰富的规则引擎**：通过 `config.json` 支持基于文件名、命令行、父进程命令行和文件哈希（SHA256）的复杂拦截/放行策略。
- **结构化日志**：所有检测和动作事件都以 JSON 格式记录在 `hips.log.json` 文件中，便于机器分析和集成。

---

## 工作原理详解

本 HIPS 的工作原理较为复杂，它融合了多种 eBPF 技术以解决在实践中遇到的各种挑战。核心流程分为内核态和用户态两大部分。

### 内核态 (eBPF C Code)

内核中的 eBPF 程序负责在性能要求最高的前线进行数据采集和初步过滤。

#### 1. “入口/出口探针”关联 (解决 `cmdline` 读取难题)

这是本程序最核心的技术。单独使用 `execve` 的入口探针无法保证能读到准确的 `cmdline`。我们的解决方案是：

- **`sys_enter_execve` (入口探针)**: 当一个新进程开始执行时，此探针触发。它只做一件极快的事：在一个临时的 BPF `hash map` (`exec_data_map`) 中，以 `PID` 为键，存入该进程的 `filename`。

- **`sys_exit_execve` (出口探针)**: 当 `execve` 系统调用即将完成并返回时，此探针触发。此时，内核已确保 `/proc` 文件系统中关于此进程的所有信息（包括 `cmdline`）都已准备就绪。出口探针根据当前 `PID` 从 `map` 中取回之前存好的 `filename`，然后将这个**可靠的事件**（包含PID和filename）发送给用户态的 Python 程序。同时，它会从 `map` 中删除该条目以回收空间。

通过这个“接力”过程，我们确保了用户态程序总是在最准确的时机去读取进程信息。

#### 2. 内核态“快速放行”白名单

为了避免监控常用命令（如 `ls`, `cat`）带来的性能开销和不佳体验，我们设计了内核态的快速通道：

- 程序启动时，`config.json` 中 `kernel_allowlist` 列表里的程序路径被加载到一个 BPF `hash map` (`kernel_allowlist_map`) 中。
- 在**出口探针**中，我们做的第一件事就是检查当前进程的 `filename` 是否存在于这个 `map` 中。
- 如果存在，探针会**立即返回**，不执行任何后续操作（不发送事件，不暂停进程）。这使得白名单中的命令能以零开销、零延迟的方式运行。

#### 3. “安全模式”下的 `SIGSTOP`

- 如果一个进程**没有**在快速放行名单中，出口探针在将事件发送给用户态之后，会执行 `bpf_send_signal(SIGSTOP)`。
- 这个信号会**立即暂停**该进程，使其无法在用户态做出决策前执行任何代码。这从根本上杜绝了恶意脚本“执行过快而来不及拦截”的竞争问题。
- 这个操作只在默认的**安全模式**下执行。在**功能模式** (`--functional`)下，这一行代码不会被编译进去。

### 用户态 (Python Script)

用户态的 Python 脚本是决策中心，负责处理内核发送上来的“待审查”事件。

1.  **事件接收与丰富**: 脚本从 eBPF 的 `perf buffer` 中接收到包含 `pid` 和 `filename` 的事件。

2.  **信息采集**: 它会立刻访问 `/proc/<PID>/` 目录，采集更丰富的信息：
    -   `/proc/<PID>/cmdline`: 读取完整的命令行参数。
    -   `/proc/<PID>/status`: 读取父进程ID (`PPID`)。
    -   `/proc/<PPID>/cmdline`: 读取父进程的命令行。
    -   `hashlib`: 计算可执行文件的 SHA256 哈希值。

3.  **决策制定**: 脚本将采集到的完整信息与 `config.json` 中的 `allowlist` 和 `blocklist` 规则进行匹配。决策顺序为：**放行名单 -> 拦截名单 -> 默认放行**。

4.  **执行动作**: 
    -   如果决定**拦截**，脚本发送 `SIGKILL` 信号终止进程。
    -   如果决定**放行**，并且当前是**安全模式**，脚本会发送 `SIGCONT` 信号来恢复之前被暂停的进程。

5.  **日志记录**: 所有的检测事件和最终的动作（拦截/放行）都会被构造成一个 JSON 对象，并追加写入到 `hips.log.json` 文件中。

---

## 文件与配置

- `hips.py`: 主程序，包含 eBPF C 代码和 Python 控制逻辑。
- `config.json`: 配置文件，用于定义三类规则：
    - `kernel_allowlist`: 内核态快速放行名单（字符串列表）。
    - `allowlist`: 用户态精细化放行规则（对象列表）。
    - `blocklist`: 用户态拦截规则（对象列表）。
- `hips.log.json`: 输出的结构化日志文件。

---

## 安装与使用

1.  **安装依赖** (Debian/Ubuntu示例):
    ```bash
    sudo apt-get update
    sudo apt-get install -y python3-bpfcc bpfcc-tools libbpfcc linux-headers-$(uname -r)
    ```

2.  **运行 HIPS**:
    - **安全模式 (默认, 推荐)**:
      ```bash
      sudo python3 hips.py
      ```
    - **功能模式 (用于调试, `cmdline`绝对准确)**:
      ```bash
      sudo python3 hips.py --functional
      ```

3.  **测试与验证**:
    - 在另一个终端执行 `ls`, `date`, `ncat`, `curl` 等命令。
    - 通过 `cat hips.log.json` 或 `tail -f hips.log.json` 查看实时日志输出。
